/* 
 * SIRIUS Nightsky API
 *
 * REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.
 *
 * OpenAPI spec version: v0.9 on SIRIUS 5.6.0-SNAPSHOT
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Object to submit a job to be executed by SIRIUS
    /// </summary>
    [DataContract]
        public partial class JobSubmission :  IEquatable<JobSubmission>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="JobSubmission" /> class.
        /// </summary>
        /// <param name="compoundIds">Compounds that should be the input for this Job.</param>
        /// <param name="fallbackAdducts">Describes how to deal with Adducts: Fallback adducts are considered if the auto detection did not find any indication for an ion mode.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-.</param>
        /// <param name="enforcedAdducts">Describes how to deal with Adducts:  Enforced adducts that are always considered.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-.</param>
        /// <param name="detectableAdducts">Describes how to deal with Adducts: Detectable adducts which are only considered if there is an indication in the MS1 scan (e.g. correct mass delta).  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-.</param>
        /// <param name="recompute">Indicate if already existing result for a tool to be executed should be overwritten or not..</param>
        /// <param name="formulaIdParas">formulaIdParas.</param>
        /// <param name="zodiacParas">zodiacParas.</param>
        /// <param name="fingerprintPredictionParas">fingerprintPredictionParas.</param>
        /// <param name="structureDbSearchParas">structureDbSearchParas.</param>
        /// <param name="canopusParas">canopusParas.</param>
        /// <param name="configMap">As an alternative to the object based parameters, this map allows to store key value pairs  of ALL SIRIUS parameters. All possible parameters can be retrieved from SIRIUS via the respective endpoint..</param>
        public JobSubmission(List<string> compoundIds = default(List<string>), List<string> fallbackAdducts = default(List<string>), List<string> enforcedAdducts = default(List<string>), List<string> detectableAdducts = default(List<string>), bool? recompute = default(bool?), Sirius formulaIdParas = default(Sirius), Zodiac zodiacParas = default(Zodiac), FingerprintPrediction fingerprintPredictionParas = default(FingerprintPrediction), StructureDbSearch structureDbSearchParas = default(StructureDbSearch), Canopus canopusParas = default(Canopus), Dictionary<string, string> configMap = default(Dictionary<string, string>))
        {
            this.CompoundIds = compoundIds;
            this.FallbackAdducts = fallbackAdducts;
            this.EnforcedAdducts = enforcedAdducts;
            this.DetectableAdducts = detectableAdducts;
            this.Recompute = recompute;
            this.FormulaIdParas = formulaIdParas;
            this.ZodiacParas = zodiacParas;
            this.FingerprintPredictionParas = fingerprintPredictionParas;
            this.StructureDbSearchParas = structureDbSearchParas;
            this.CanopusParas = canopusParas;
            this.ConfigMap = configMap;
        }
        
        /// <summary>
        /// Compounds that should be the input for this Job
        /// </summary>
        /// <value>Compounds that should be the input for this Job</value>
        [DataMember(Name="compoundIds", EmitDefaultValue=false)]
        public List<string> CompoundIds { get; set; }

        /// <summary>
        /// Describes how to deal with Adducts: Fallback adducts are considered if the auto detection did not find any indication for an ion mode.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-
        /// </summary>
        /// <value>Describes how to deal with Adducts: Fallback adducts are considered if the auto detection did not find any indication for an ion mode.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-</value>
        [DataMember(Name="fallbackAdducts", EmitDefaultValue=false)]
        public List<string> FallbackAdducts { get; set; }

        /// <summary>
        /// Describes how to deal with Adducts:  Enforced adducts that are always considered.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-
        /// </summary>
        /// <value>Describes how to deal with Adducts:  Enforced adducts that are always considered.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-</value>
        [DataMember(Name="enforcedAdducts", EmitDefaultValue=false)]
        public List<string> EnforcedAdducts { get; set; }

        /// <summary>
        /// Describes how to deal with Adducts: Detectable adducts which are only considered if there is an indication in the MS1 scan (e.g. correct mass delta).  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-
        /// </summary>
        /// <value>Describes how to deal with Adducts: Detectable adducts which are only considered if there is an indication in the MS1 scan (e.g. correct mass delta).  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-</value>
        [DataMember(Name="detectableAdducts", EmitDefaultValue=false)]
        public List<string> DetectableAdducts { get; set; }

        /// <summary>
        /// Indicate if already existing result for a tool to be executed should be overwritten or not.
        /// </summary>
        /// <value>Indicate if already existing result for a tool to be executed should be overwritten or not.</value>
        [DataMember(Name="recompute", EmitDefaultValue=false)]
        public bool? Recompute { get; set; }

        /// <summary>
        /// Gets or Sets FormulaIdParas
        /// </summary>
        [DataMember(Name="formulaIdParas", EmitDefaultValue=false)]
        public Sirius FormulaIdParas { get; set; }

        /// <summary>
        /// Gets or Sets ZodiacParas
        /// </summary>
        [DataMember(Name="zodiacParas", EmitDefaultValue=false)]
        public Zodiac ZodiacParas { get; set; }

        /// <summary>
        /// Gets or Sets FingerprintPredictionParas
        /// </summary>
        [DataMember(Name="fingerprintPredictionParas", EmitDefaultValue=false)]
        public FingerprintPrediction FingerprintPredictionParas { get; set; }

        /// <summary>
        /// Gets or Sets StructureDbSearchParas
        /// </summary>
        [DataMember(Name="structureDbSearchParas", EmitDefaultValue=false)]
        public StructureDbSearch StructureDbSearchParas { get; set; }

        /// <summary>
        /// Gets or Sets CanopusParas
        /// </summary>
        [DataMember(Name="canopusParas", EmitDefaultValue=false)]
        public Canopus CanopusParas { get; set; }

        /// <summary>
        /// As an alternative to the object based parameters, this map allows to store key value pairs  of ALL SIRIUS parameters. All possible parameters can be retrieved from SIRIUS via the respective endpoint.
        /// </summary>
        /// <value>As an alternative to the object based parameters, this map allows to store key value pairs  of ALL SIRIUS parameters. All possible parameters can be retrieved from SIRIUS via the respective endpoint.</value>
        [DataMember(Name="configMap", EmitDefaultValue=false)]
        public Dictionary<string, string> ConfigMap { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class JobSubmission {\n");
            sb.Append("  CompoundIds: ").Append(CompoundIds).Append("\n");
            sb.Append("  FallbackAdducts: ").Append(FallbackAdducts).Append("\n");
            sb.Append("  EnforcedAdducts: ").Append(EnforcedAdducts).Append("\n");
            sb.Append("  DetectableAdducts: ").Append(DetectableAdducts).Append("\n");
            sb.Append("  Recompute: ").Append(Recompute).Append("\n");
            sb.Append("  FormulaIdParas: ").Append(FormulaIdParas).Append("\n");
            sb.Append("  ZodiacParas: ").Append(ZodiacParas).Append("\n");
            sb.Append("  FingerprintPredictionParas: ").Append(FingerprintPredictionParas).Append("\n");
            sb.Append("  StructureDbSearchParas: ").Append(StructureDbSearchParas).Append("\n");
            sb.Append("  CanopusParas: ").Append(CanopusParas).Append("\n");
            sb.Append("  ConfigMap: ").Append(ConfigMap).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as JobSubmission);
        }

        /// <summary>
        /// Returns true if JobSubmission instances are equal
        /// </summary>
        /// <param name="input">Instance of JobSubmission to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(JobSubmission input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.CompoundIds == input.CompoundIds ||
                    this.CompoundIds != null &&
                    input.CompoundIds != null &&
                    this.CompoundIds.SequenceEqual(input.CompoundIds)
                ) && 
                (
                    this.FallbackAdducts == input.FallbackAdducts ||
                    this.FallbackAdducts != null &&
                    input.FallbackAdducts != null &&
                    this.FallbackAdducts.SequenceEqual(input.FallbackAdducts)
                ) && 
                (
                    this.EnforcedAdducts == input.EnforcedAdducts ||
                    this.EnforcedAdducts != null &&
                    input.EnforcedAdducts != null &&
                    this.EnforcedAdducts.SequenceEqual(input.EnforcedAdducts)
                ) && 
                (
                    this.DetectableAdducts == input.DetectableAdducts ||
                    this.DetectableAdducts != null &&
                    input.DetectableAdducts != null &&
                    this.DetectableAdducts.SequenceEqual(input.DetectableAdducts)
                ) && 
                (
                    this.Recompute == input.Recompute ||
                    (this.Recompute != null &&
                    this.Recompute.Equals(input.Recompute))
                ) && 
                (
                    this.FormulaIdParas == input.FormulaIdParas ||
                    (this.FormulaIdParas != null &&
                    this.FormulaIdParas.Equals(input.FormulaIdParas))
                ) && 
                (
                    this.ZodiacParas == input.ZodiacParas ||
                    (this.ZodiacParas != null &&
                    this.ZodiacParas.Equals(input.ZodiacParas))
                ) && 
                (
                    this.FingerprintPredictionParas == input.FingerprintPredictionParas ||
                    (this.FingerprintPredictionParas != null &&
                    this.FingerprintPredictionParas.Equals(input.FingerprintPredictionParas))
                ) && 
                (
                    this.StructureDbSearchParas == input.StructureDbSearchParas ||
                    (this.StructureDbSearchParas != null &&
                    this.StructureDbSearchParas.Equals(input.StructureDbSearchParas))
                ) && 
                (
                    this.CanopusParas == input.CanopusParas ||
                    (this.CanopusParas != null &&
                    this.CanopusParas.Equals(input.CanopusParas))
                ) && 
                (
                    this.ConfigMap == input.ConfigMap ||
                    this.ConfigMap != null &&
                    input.ConfigMap != null &&
                    this.ConfigMap.SequenceEqual(input.ConfigMap)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CompoundIds != null)
                    hashCode = hashCode * 59 + this.CompoundIds.GetHashCode();
                if (this.FallbackAdducts != null)
                    hashCode = hashCode * 59 + this.FallbackAdducts.GetHashCode();
                if (this.EnforcedAdducts != null)
                    hashCode = hashCode * 59 + this.EnforcedAdducts.GetHashCode();
                if (this.DetectableAdducts != null)
                    hashCode = hashCode * 59 + this.DetectableAdducts.GetHashCode();
                if (this.Recompute != null)
                    hashCode = hashCode * 59 + this.Recompute.GetHashCode();
                if (this.FormulaIdParas != null)
                    hashCode = hashCode * 59 + this.FormulaIdParas.GetHashCode();
                if (this.ZodiacParas != null)
                    hashCode = hashCode * 59 + this.ZodiacParas.GetHashCode();
                if (this.FingerprintPredictionParas != null)
                    hashCode = hashCode * 59 + this.FingerprintPredictionParas.GetHashCode();
                if (this.StructureDbSearchParas != null)
                    hashCode = hashCode * 59 + this.StructureDbSearchParas.GetHashCode();
                if (this.CanopusParas != null)
                    hashCode = hashCode * 59 + this.CanopusParas.GetHashCode();
                if (this.ConfigMap != null)
                    hashCode = hashCode * 59 + this.ConfigMap.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
