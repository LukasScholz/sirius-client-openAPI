/* 
 * SIRIUS Nightsky API
 *
 * REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.
 *
 * OpenAPI spec version: v0.9 on SIRIUS 5.6.0-SNAPSHOT
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// User/developer friendly parameter subset for the Formula/SIRIUS tool
    /// </summary>
    [DataContract]
        public partial class Sirius :  IEquatable<Sirius>, IValidatableObject
    {
        /// <summary>
        /// Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.
        /// </summary>
        /// <value>Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum ProfileEnum
        {
            /// <summary>
            /// Enum QTOF for value: QTOF
            /// </summary>
            [EnumMember(Value = "QTOF")]
            QTOF = 1,
            /// <summary>
            /// Enum ORBI for value: ORBI
            /// </summary>
            [EnumMember(Value = "ORBI")]
            ORBI = 2,
            /// <summary>
            /// Enum FTICR for value: FTICR
            /// </summary>
            [EnumMember(Value = "FTICR")]
            FTICR = 3        }
        /// <summary>
        /// Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.
        /// </summary>
        /// <value>Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.</value>
        [DataMember(Name="profile", EmitDefaultValue=false)]
        public ProfileEnum? Profile { get; set; }
        /// <summary>
        /// Specify how isotope patterns in MS/MS should be handled.  &lt;p&gt;  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  &lt;p&gt;  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  &lt;p&gt;  IGNORE: Ignore that there might be isotope patterns in MS/MS
        /// </summary>
        /// <value>Specify how isotope patterns in MS/MS should be handled.  &lt;p&gt;  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  &lt;p&gt;  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  &lt;p&gt;  IGNORE: Ignore that there might be isotope patterns in MS/MS</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum IsotopeMs2SettingsEnum
        {
            /// <summary>
            /// Enum IGNORE for value: IGNORE
            /// </summary>
            [EnumMember(Value = "IGNORE")]
            IGNORE = 1,
            /// <summary>
            /// Enum FILTER for value: FILTER
            /// </summary>
            [EnumMember(Value = "FILTER")]
            FILTER = 2,
            /// <summary>
            /// Enum SCORE for value: SCORE
            /// </summary>
            [EnumMember(Value = "SCORE")]
            SCORE = 3        }
        /// <summary>
        /// Specify how isotope patterns in MS/MS should be handled.  &lt;p&gt;  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  &lt;p&gt;  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  &lt;p&gt;  IGNORE: Ignore that there might be isotope patterns in MS/MS
        /// </summary>
        /// <value>Specify how isotope patterns in MS/MS should be handled.  &lt;p&gt;  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  &lt;p&gt;  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  &lt;p&gt;  IGNORE: Ignore that there might be isotope patterns in MS/MS</value>
        [DataMember(Name="isotopeMs2Settings", EmitDefaultValue=false)]
        public IsotopeMs2SettingsEnum? IsotopeMs2Settings { get; set; }
        /// <summary>
        /// Defines FormulaSearchDBs
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum FormulaSearchDBsEnum
        {
            /// <summary>
            /// Enum ALL for value: ALL
            /// </summary>
            [EnumMember(Value = "ALL")]
            ALL = 1,
            /// <summary>
            /// Enum ALLBUTINSILICO for value: ALL_BUT_INSILICO
            /// </summary>
            [EnumMember(Value = "ALL_BUT_INSILICO")]
            ALLBUTINSILICO = 2,
            /// <summary>
            /// Enum PUBCHEM for value: PUBCHEM
            /// </summary>
            [EnumMember(Value = "PUBCHEM")]
            PUBCHEM = 3,
            /// <summary>
            /// Enum MESH for value: MESH
            /// </summary>
            [EnumMember(Value = "MESH")]
            MESH = 4,
            /// <summary>
            /// Enum HMDB for value: HMDB
            /// </summary>
            [EnumMember(Value = "HMDB")]
            HMDB = 5,
            /// <summary>
            /// Enum KNAPSACK for value: KNAPSACK
            /// </summary>
            [EnumMember(Value = "KNAPSACK")]
            KNAPSACK = 6,
            /// <summary>
            /// Enum CHEBI for value: CHEBI
            /// </summary>
            [EnumMember(Value = "CHEBI")]
            CHEBI = 7,
            /// <summary>
            /// Enum PUBMED for value: PUBMED
            /// </summary>
            [EnumMember(Value = "PUBMED")]
            PUBMED = 8,
            /// <summary>
            /// Enum BIO for value: BIO
            /// </summary>
            [EnumMember(Value = "BIO")]
            BIO = 9,
            /// <summary>
            /// Enum KEGG for value: KEGG
            /// </summary>
            [EnumMember(Value = "KEGG")]
            KEGG = 10,
            /// <summary>
            /// Enum HSDB for value: HSDB
            /// </summary>
            [EnumMember(Value = "HSDB")]
            HSDB = 11,
            /// <summary>
            /// Enum MACONDA for value: MACONDA
            /// </summary>
            [EnumMember(Value = "MACONDA")]
            MACONDA = 12,
            /// <summary>
            /// Enum METACYC for value: METACYC
            /// </summary>
            [EnumMember(Value = "METACYC")]
            METACYC = 13,
            /// <summary>
            /// Enum GNPS for value: GNPS
            /// </summary>
            [EnumMember(Value = "GNPS")]
            GNPS = 14,
            /// <summary>
            /// Enum ZINCBIO for value: ZINCBIO
            /// </summary>
            [EnumMember(Value = "ZINCBIO")]
            ZINCBIO = 15,
            /// <summary>
            /// Enum TRAIN for value: TRAIN
            /// </summary>
            [EnumMember(Value = "TRAIN")]
            TRAIN = 16,
            /// <summary>
            /// Enum UNDP for value: UNDP
            /// </summary>
            [EnumMember(Value = "UNDP")]
            UNDP = 17,
            /// <summary>
            /// Enum YMDB for value: YMDB
            /// </summary>
            [EnumMember(Value = "YMDB")]
            YMDB = 18,
            /// <summary>
            /// Enum PLANTCYC for value: PLANTCYC
            /// </summary>
            [EnumMember(Value = "PLANTCYC")]
            PLANTCYC = 19,
            /// <summary>
            /// Enum NORMAN for value: NORMAN
            /// </summary>
            [EnumMember(Value = "NORMAN")]
            NORMAN = 20,
            /// <summary>
            /// Enum ADDITIONAL for value: ADDITIONAL
            /// </summary>
            [EnumMember(Value = "ADDITIONAL")]
            ADDITIONAL = 21,
            /// <summary>
            /// Enum SUPERNATURAL for value: SUPERNATURAL
            /// </summary>
            [EnumMember(Value = "SUPERNATURAL")]
            SUPERNATURAL = 22,
            /// <summary>
            /// Enum COCONUT for value: COCONUT
            /// </summary>
            [EnumMember(Value = "COCONUT")]
            COCONUT = 23,
            /// <summary>
            /// Enum PUBCHEMANNOTATIONBIO for value: PUBCHEMANNOTATIONBIO
            /// </summary>
            [EnumMember(Value = "PUBCHEMANNOTATIONBIO")]
            PUBCHEMANNOTATIONBIO = 24,
            /// <summary>
            /// Enum PUBCHEMANNOTATIONDRUG for value: PUBCHEMANNOTATIONDRUG
            /// </summary>
            [EnumMember(Value = "PUBCHEMANNOTATIONDRUG")]
            PUBCHEMANNOTATIONDRUG = 25,
            /// <summary>
            /// Enum PUBCHEMANNOTATIONSAFETYANDTOXIC for value: PUBCHEMANNOTATIONSAFETYANDTOXIC
            /// </summary>
            [EnumMember(Value = "PUBCHEMANNOTATIONSAFETYANDTOXIC")]
            PUBCHEMANNOTATIONSAFETYANDTOXIC = 26,
            /// <summary>
            /// Enum PUBCHEMANNOTATIONFOOD for value: PUBCHEMANNOTATIONFOOD
            /// </summary>
            [EnumMember(Value = "PUBCHEMANNOTATIONFOOD")]
            PUBCHEMANNOTATIONFOOD = 27,
            /// <summary>
            /// Enum LIPID for value: LIPID
            /// </summary>
            [EnumMember(Value = "LIPID")]
            LIPID = 28,
            /// <summary>
            /// Enum KEGGMINE for value: KEGGMINE
            /// </summary>
            [EnumMember(Value = "KEGGMINE")]
            KEGGMINE = 29,
            /// <summary>
            /// Enum ECOCYCMINE for value: ECOCYCMINE
            /// </summary>
            [EnumMember(Value = "ECOCYCMINE")]
            ECOCYCMINE = 30,
            /// <summary>
            /// Enum YMDBMINE for value: YMDBMINE
            /// </summary>
            [EnumMember(Value = "YMDBMINE")]
            YMDBMINE = 31        }
        /// <summary>
        /// List Structure database to extract molecular formulas from to reduce formula search space.  SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason.
        /// </summary>
        /// <value>List Structure database to extract molecular formulas from to reduce formula search space.  SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason.</value>
        [DataMember(Name="formulaSearchDBs", EmitDefaultValue=false)]
        public List<FormulaSearchDBsEnum> FormulaSearchDBs { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Sirius" /> class.
        /// </summary>
        /// <param name="enabled">tags whether the tool is enabled.</param>
        /// <param name="profile">Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data..</param>
        /// <param name="numberOfCandidates">Number of formula candidates to keep as result list (Formula Candidates)..</param>
        /// <param name="numberOfCandidatesPerIon">Use this parameter if you want to force SIRIUS to report at least  NumberOfCandidatesPerIon results per ionization.  if &lt;&#x3D; 0, this parameter will have no effect and just the top  NumberOfCandidates results will be reported..</param>
        /// <param name="massAccuracyMS2ppm">Maximum allowed mass accuracy. Only molecular formulas within this mass window are considered..</param>
        /// <param name="isotopeMs2Settings">Specify how isotope patterns in MS/MS should be handled.  &lt;p&gt;  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  &lt;p&gt;  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  &lt;p&gt;  IGNORE: Ignore that there might be isotope patterns in MS/MS.</param>
        /// <param name="formulaSearchDBs">List Structure database to extract molecular formulas from to reduce formula search space.  SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason..</param>
        /// <param name="enforcedFormulaConstraints">These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Enforced: Enforced elements are always considered.</param>
        /// <param name="fallbackFormulaConstraints">These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available).</param>
        /// <param name="detectableElements">These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern).</param>
        /// <param name="ilpTimeout">ilpTimeout.</param>
        /// <param name="useHeuristic">useHeuristic.</param>
        public Sirius(bool? enabled = default(bool?), ProfileEnum? profile = default(ProfileEnum?), int? numberOfCandidates = default(int?), int? numberOfCandidatesPerIon = default(int?), double? massAccuracyMS2ppm = default(double?), IsotopeMs2SettingsEnum? isotopeMs2Settings = default(IsotopeMs2SettingsEnum?), List<FormulaSearchDBsEnum> formulaSearchDBs = default(List<FormulaSearchDBsEnum>), string enforcedFormulaConstraints = default(string), string fallbackFormulaConstraints = default(string), List<string> detectableElements = default(List<string>), Timeout ilpTimeout = default(Timeout), UseHeuristic useHeuristic = default(UseHeuristic))
        {
            this.Enabled = enabled;
            this.Profile = profile;
            this.NumberOfCandidates = numberOfCandidates;
            this.NumberOfCandidatesPerIon = numberOfCandidatesPerIon;
            this.MassAccuracyMS2ppm = massAccuracyMS2ppm;
            this.IsotopeMs2Settings = isotopeMs2Settings;
            this.FormulaSearchDBs = formulaSearchDBs;
            this.EnforcedFormulaConstraints = enforcedFormulaConstraints;
            this.FallbackFormulaConstraints = fallbackFormulaConstraints;
            this.DetectableElements = detectableElements;
            this.IlpTimeout = ilpTimeout;
            this.UseHeuristic = useHeuristic;
        }
        
        /// <summary>
        /// tags whether the tool is enabled
        /// </summary>
        /// <value>tags whether the tool is enabled</value>
        [DataMember(Name="enabled", EmitDefaultValue=false)]
        public bool? Enabled { get; set; }


        /// <summary>
        /// Number of formula candidates to keep as result list (Formula Candidates).
        /// </summary>
        /// <value>Number of formula candidates to keep as result list (Formula Candidates).</value>
        [DataMember(Name="numberOfCandidates", EmitDefaultValue=false)]
        public int? NumberOfCandidates { get; set; }

        /// <summary>
        /// Use this parameter if you want to force SIRIUS to report at least  NumberOfCandidatesPerIon results per ionization.  if &lt;&#x3D; 0, this parameter will have no effect and just the top  NumberOfCandidates results will be reported.
        /// </summary>
        /// <value>Use this parameter if you want to force SIRIUS to report at least  NumberOfCandidatesPerIon results per ionization.  if &lt;&#x3D; 0, this parameter will have no effect and just the top  NumberOfCandidates results will be reported.</value>
        [DataMember(Name="numberOfCandidatesPerIon", EmitDefaultValue=false)]
        public int? NumberOfCandidatesPerIon { get; set; }

        /// <summary>
        /// Maximum allowed mass accuracy. Only molecular formulas within this mass window are considered.
        /// </summary>
        /// <value>Maximum allowed mass accuracy. Only molecular formulas within this mass window are considered.</value>
        [DataMember(Name="massAccuracyMS2ppm", EmitDefaultValue=false)]
        public double? MassAccuracyMS2ppm { get; set; }



        /// <summary>
        /// These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Enforced: Enforced elements are always considered
        /// </summary>
        /// <value>These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Enforced: Enforced elements are always considered</value>
        [DataMember(Name="enforcedFormulaConstraints", EmitDefaultValue=false)]
        public string EnforcedFormulaConstraints { get; set; }

        /// <summary>
        /// These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available)
        /// </summary>
        /// <value>These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available)</value>
        [DataMember(Name="fallbackFormulaConstraints", EmitDefaultValue=false)]
        public string FallbackFormulaConstraints { get; set; }

        /// <summary>
        /// These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern)
        /// </summary>
        /// <value>These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern)</value>
        [DataMember(Name="detectableElements", EmitDefaultValue=false)]
        public List<string> DetectableElements { get; set; }

        /// <summary>
        /// Gets or Sets IlpTimeout
        /// </summary>
        [DataMember(Name="ilpTimeout", EmitDefaultValue=false)]
        public Timeout IlpTimeout { get; set; }

        /// <summary>
        /// Gets or Sets UseHeuristic
        /// </summary>
        [DataMember(Name="useHeuristic", EmitDefaultValue=false)]
        public UseHeuristic UseHeuristic { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Sirius {\n");
            sb.Append("  Enabled: ").Append(Enabled).Append("\n");
            sb.Append("  Profile: ").Append(Profile).Append("\n");
            sb.Append("  NumberOfCandidates: ").Append(NumberOfCandidates).Append("\n");
            sb.Append("  NumberOfCandidatesPerIon: ").Append(NumberOfCandidatesPerIon).Append("\n");
            sb.Append("  MassAccuracyMS2ppm: ").Append(MassAccuracyMS2ppm).Append("\n");
            sb.Append("  IsotopeMs2Settings: ").Append(IsotopeMs2Settings).Append("\n");
            sb.Append("  FormulaSearchDBs: ").Append(FormulaSearchDBs).Append("\n");
            sb.Append("  EnforcedFormulaConstraints: ").Append(EnforcedFormulaConstraints).Append("\n");
            sb.Append("  FallbackFormulaConstraints: ").Append(FallbackFormulaConstraints).Append("\n");
            sb.Append("  DetectableElements: ").Append(DetectableElements).Append("\n");
            sb.Append("  IlpTimeout: ").Append(IlpTimeout).Append("\n");
            sb.Append("  UseHeuristic: ").Append(UseHeuristic).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Sirius);
        }

        /// <summary>
        /// Returns true if Sirius instances are equal
        /// </summary>
        /// <param name="input">Instance of Sirius to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Sirius input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Enabled == input.Enabled ||
                    (this.Enabled != null &&
                    this.Enabled.Equals(input.Enabled))
                ) && 
                (
                    this.Profile == input.Profile ||
                    (this.Profile != null &&
                    this.Profile.Equals(input.Profile))
                ) && 
                (
                    this.NumberOfCandidates == input.NumberOfCandidates ||
                    (this.NumberOfCandidates != null &&
                    this.NumberOfCandidates.Equals(input.NumberOfCandidates))
                ) && 
                (
                    this.NumberOfCandidatesPerIon == input.NumberOfCandidatesPerIon ||
                    (this.NumberOfCandidatesPerIon != null &&
                    this.NumberOfCandidatesPerIon.Equals(input.NumberOfCandidatesPerIon))
                ) && 
                (
                    this.MassAccuracyMS2ppm == input.MassAccuracyMS2ppm ||
                    (this.MassAccuracyMS2ppm != null &&
                    this.MassAccuracyMS2ppm.Equals(input.MassAccuracyMS2ppm))
                ) && 
                (
                    this.IsotopeMs2Settings == input.IsotopeMs2Settings ||
                    (this.IsotopeMs2Settings != null &&
                    this.IsotopeMs2Settings.Equals(input.IsotopeMs2Settings))
                ) && 
                (
                    this.FormulaSearchDBs == input.FormulaSearchDBs ||
                    this.FormulaSearchDBs != null &&
                    input.FormulaSearchDBs != null &&
                    this.FormulaSearchDBs.SequenceEqual(input.FormulaSearchDBs)
                ) && 
                (
                    this.EnforcedFormulaConstraints == input.EnforcedFormulaConstraints ||
                    (this.EnforcedFormulaConstraints != null &&
                    this.EnforcedFormulaConstraints.Equals(input.EnforcedFormulaConstraints))
                ) && 
                (
                    this.FallbackFormulaConstraints == input.FallbackFormulaConstraints ||
                    (this.FallbackFormulaConstraints != null &&
                    this.FallbackFormulaConstraints.Equals(input.FallbackFormulaConstraints))
                ) && 
                (
                    this.DetectableElements == input.DetectableElements ||
                    this.DetectableElements != null &&
                    input.DetectableElements != null &&
                    this.DetectableElements.SequenceEqual(input.DetectableElements)
                ) && 
                (
                    this.IlpTimeout == input.IlpTimeout ||
                    (this.IlpTimeout != null &&
                    this.IlpTimeout.Equals(input.IlpTimeout))
                ) && 
                (
                    this.UseHeuristic == input.UseHeuristic ||
                    (this.UseHeuristic != null &&
                    this.UseHeuristic.Equals(input.UseHeuristic))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Enabled != null)
                    hashCode = hashCode * 59 + this.Enabled.GetHashCode();
                if (this.Profile != null)
                    hashCode = hashCode * 59 + this.Profile.GetHashCode();
                if (this.NumberOfCandidates != null)
                    hashCode = hashCode * 59 + this.NumberOfCandidates.GetHashCode();
                if (this.NumberOfCandidatesPerIon != null)
                    hashCode = hashCode * 59 + this.NumberOfCandidatesPerIon.GetHashCode();
                if (this.MassAccuracyMS2ppm != null)
                    hashCode = hashCode * 59 + this.MassAccuracyMS2ppm.GetHashCode();
                if (this.IsotopeMs2Settings != null)
                    hashCode = hashCode * 59 + this.IsotopeMs2Settings.GetHashCode();
                if (this.FormulaSearchDBs != null)
                    hashCode = hashCode * 59 + this.FormulaSearchDBs.GetHashCode();
                if (this.EnforcedFormulaConstraints != null)
                    hashCode = hashCode * 59 + this.EnforcedFormulaConstraints.GetHashCode();
                if (this.FallbackFormulaConstraints != null)
                    hashCode = hashCode * 59 + this.FallbackFormulaConstraints.GetHashCode();
                if (this.DetectableElements != null)
                    hashCode = hashCode * 59 + this.DetectableElements.GetHashCode();
                if (this.IlpTimeout != null)
                    hashCode = hashCode * 59 + this.IlpTimeout.GetHashCode();
                if (this.UseHeuristic != null)
                    hashCode = hashCode * 59 + this.UseHeuristic.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
