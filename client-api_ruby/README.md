# ruby_sirius

RubySirius - the Ruby gem for the SIRIUS Nightsky API

REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.

This SDK is automatically generated by the [Swagger Codegen](https://github.com/swagger-api/swagger-codegen) project:

- API version: v0.9 on SIRIUS 5.6.0-SNAPSHOT
- Package version: 1.0.0
- Build package: io.swagger.codegen.v3.generators.ruby.RubyClientCodegen

## Installation

### Build a gem

To build the Ruby code into a gem:

```shell
gem build ruby_sirius.gemspec
```

Then either install the gem locally:

```shell
gem install ./ruby_sirius-1.0.0.gem
```
(for development, run `gem install --dev ./ruby_sirius-1.0.0.gem` to install the development dependencies)

or publish the gem to a gem hosting service, e.g. [RubyGems](https://rubygems.org/).

Finally add this to the Gemfile:

    gem 'ruby_sirius', '~> 1.0.0'

### Install from Git

If the Ruby gem is hosted at a git repository: https://github.com/GIT_USER_ID/GIT_REPO_ID, then add the following in the Gemfile:

    gem 'ruby_sirius', :git => 'https://github.com/GIT_USER_ID/GIT_REPO_ID.git'

### Include the Ruby code directly

Include the Ruby code directly using `-I` as follows:

```shell
ruby -Ilib script.rb
```

## Getting Started

Please follow the [installation](#installation) procedure and then run the following code:
```ruby
# Load the gem
require 'ruby_sirius'

api_instance = RubySirius::CompoundsApi.new
project_id = 'project_id_example' # String | project-space to delete from.
cid = 'cid_example' # String | identifier of compound to delete.


begin
  #Delete compound/feature with the given identifier from the specified project-space.
  api_instance.delete_compound(project_id, cid)
rescue RubySirius::ApiError => e
  puts "Exception when calling CompoundsApi->delete_compound: #{e}"
end

api_instance = RubySirius::CompoundsApi.new
project_id = 'project_id_example' # String | project-space to read from.
cid = 'cid_example' # String | identifier of compound to access.
opts = { 
  top_annotation: false, # BOOLEAN | include the top annotation of this feature into the output (if available).
  ms_data: false # BOOLEAN | include corresponding source data (MS and MS/MS) into the output.
}

begin
  #Get compound/feature with the given identifier from the specified project-space.
  result = api_instance.get_compound(project_id, cid, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling CompoundsApi->get_compound: #{e}"
end

api_instance = RubySirius::CompoundsApi.new
project_id = 'project_id_example' # String | project-space to read from.
opts = { 
  top_annotation: false, # BOOLEAN | include the top annotation of this feature into the output (if available).
  ms_data: false # BOOLEAN | include corresponding source data (MS and MS/MS) into the output.
}

begin
  #Get all available compounds/features in the given project-space.
  result = api_instance.get_compounds(project_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling CompoundsApi->get_compounds: #{e}"
end

api_instance = RubySirius::CompoundsApi.new
body = ['body_example'] # Array<String> | List of file and directory paths to import
project_id = 'project_id_example' # String | project-space to import into.
opts = { 
  align_lcms_runs: false, # BOOLEAN | If true, multiple LCMS Runs (mzML, mzXML) will be aligned during import/feature finding
  allow_ms1_only_data: true, # BOOLEAN | 
  ignore_formulas: false # BOOLEAN | 
}

begin
  #Import ms/ms data in given format from local filesystem into the specified project-space
  result = api_instance.import_compounds(body, project_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling CompoundsApi->import_compounds: #{e}"
end

api_instance = RubySirius::CompoundsApi.new
body = 'body_example' # String | data content in specified format
project_id = 'project_id_example' # String | project-space to import into.
format = 'format_example' # String | data format specified by the usual file extension of the format (without [.])
opts = { 
  source_name: 'source_name_example' # String | name that specifies the data source. Can e.g. be a file path or just a name.
}

begin
  #Import ms/ms data from the given format into the specified project-space  Possible formats (ms, mgf, cef, msp, mzML, mzXML)
  result = api_instance.import_compounds_from_string(body, project_id, format, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling CompoundsApi->import_compounds_from_string: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
project_id = 'project_id_example' # String | project-space to run jobs on
job_id = 'job_id_example' # String | of the job to be deleted
opts = { 
  cancel_if_running: true, # BOOLEAN | If true job will be canceled if it is not finished. Otherwise,                         deletion will fail for running jobs or request will block until job has finished.
  await_deletion: true # BOOLEAN | If true request will block until deletion succeeded or failed.                         If the job is still running the request will wait until the job has finished.
}

begin
  #Delete job.
  api_instance.delete_job(project_id, job_id, opts)
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->delete_job: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
name = 'name_example' # String | name of the job-config to delete


begin
  #Delete job configuration with given name.
  api_instance.delete_job_config(name)
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->delete_job_config: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
opts = { 
  include_config_map: false # BOOLEAN | if true, generic configmap with-defaults will be included
}

begin
  #Request default job configuration
  result = api_instance.get_default_job_config(opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->get_default_job_config: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
project_id = 'project_id_example' # String | project-space to run jobs on
job_id = 'job_id_example' # String | of the job to be returned
opts = { 
  include_state: true, # BOOLEAN | include {@link de.unijena.bioinf.ms.middleware.compute.model.JobProgress de.unijena.bioinf.ms.middleware.compute.model.JobProgress} state.
  include_command: false, # BOOLEAN | include job command.
  include_affected_compounds: false # BOOLEAN | include list of compound ids affected by this job (if available)
}

begin
  #Get job information and its current state and progress (if available).
  result = api_instance.get_job(project_id, job_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->get_job: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
name = 'name_example' # String | name of the job-config to return
opts = { 
  include_config_map: false # BOOLEAN | if true the generic configmap will be part of the output
}

begin
  #Request job configuration with given name.
  result = api_instance.get_job_config(name, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->get_job_config: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
opts = { 
  include_config_map: false # BOOLEAN | if true the generic configmap will be part of the output
}

begin
  #Request all available job configurations
  result = api_instance.get_job_configs(opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->get_job_configs: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
project_id = 'project_id_example' # String | project-space to run jobs on
opts = { 
  include_state: false, # BOOLEAN | include {@link de.unijena.bioinf.ms.middleware.compute.model.JobProgress de.unijena.bioinf.ms.middleware.compute.model.JobProgress} states.
  include_command: false, # BOOLEAN | include job commands.
  include_affected_compounds: false # BOOLEAN | include list of compound ids affected by this job (if available)
}

begin
  #Get job information and its current state and progress (if available).
  result = api_instance.get_jobs(project_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->get_jobs: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
body = RubySirius::JobSubmission.new # JobSubmission | to add
name = 'name_example' # String | name of the job-config to add
opts = { 
  override_existing: false # BOOLEAN | 
}

begin
  #Add new job configuration with given name.
  result = api_instance.post_job_config(body, name, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->post_job_config: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
body = RubySirius::JobSubmission.new # JobSubmission | configuration of the job that will be submitted of the job to be returned
project_id = 'project_id_example' # String | project-space to run jobs on
opts = { 
  include_state: true, # BOOLEAN | include {@link de.unijena.bioinf.ms.middleware.compute.model.JobProgress de.unijena.bioinf.ms.middleware.compute.model.JobProgress} state.
  include_command: true, # BOOLEAN | include job command.
  include_affected_compounds: false # BOOLEAN | include list of compound ids affected by this job (if available)
}

begin
  #Start computation for given compounds and with given parameters.
  result = api_instance.start_job(body, project_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->start_job: #{e}"
end

api_instance = RubySirius::ComputationsApi.new
body = ['body_example'] # Array<String> | compound ids to be computed
project_id = 'project_id_example' # String | project-space to run jobs on
job_config_name = 'job_config_name_example' # String | name if the config to be used
opts = { 
  recompute: true, # BOOLEAN | enable or disable recompute. If null the stored value will be used.
  include_state: true, # BOOLEAN | include {@link de.unijena.bioinf.ms.middleware.compute.model.JobProgress de.unijena.bioinf.ms.middleware.compute.model.JobProgress} state.
  include_command: true, # BOOLEAN | include job command.
  include_affected_compounds: false # BOOLEAN | include list of compound ids affected by this job (if available)
}

begin
  #Start computation for given compounds and with parameters from a stored job-config.
  result = api_instance.start_job_from_config(body, project_id, job_config_name, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ComputationsApi->start_job_from_config: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result


begin
  #Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,
  result = api_instance.get_best_matching_canopus_predictions(project_id, compound_id, formula_id)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_best_matching_canopus_predictions: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result


begin
  #All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,
  result = api_instance.get_canopus_predictions(project_id, compound_id, formula_id)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_canopus_predictions: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result


begin
  #Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.
  result = api_instance.get_fingerprint_prediction(project_id, compound_id, formula_id)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_fingerprint_prediction: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
opts = { 
  result_overview: true, # BOOLEAN | add ResultOverview to the FormulaResultContainers
  formula_candidate: false # BOOLEAN | add extended formula candidate information to the FormulaResultContainers
}

begin
  #List of all FormulaResultContainers available for this compound/feature with minimal information.
  result = api_instance.get_formula_ids(project_id, compound_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_formula_ids: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result
opts = { 
  result_overview: true, # BOOLEAN | add ResultOverview to the FormulaResultContainer
  formula_candidate: true # BOOLEAN | add extended formula candidate information to the FormulaResultContainer
}

begin
  #FormulaResultContainers for the given 'formulaId' with minimal information.
  result = api_instance.get_formula_result(project_id, compound_id, formula_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_formula_result: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result


begin
  #Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).
  result = api_instance.get_frag_tree(project_id, compound_id, formula_id)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_frag_tree: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result


begin
  #Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.
  result = api_instance.get_simulated_isotope_pattern(project_id, compound_id, formula_id)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_simulated_isotope_pattern: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
formula_id = 'formula_id_example' # String | identifier of the requested formula result
opts = { 
  fingerprint: false, # BOOLEAN | add molecular fingerprint to StructureCandidates
  db_links: false, # BOOLEAN | add dbLinks to StructureCandidates
  pub_med_ids: false, # BOOLEAN | add PubMedIds (citation count) to StructureCandidates
  top_k: -1 # Integer | retrieve only the top k StructureCandidates
}

begin
  #List of StructureCandidates the given 'formulaId' with minimal information.
  result = api_instance.get_structure_candidates(project_id, compound_id, formula_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_structure_candidates: #{e}"
end

api_instance = RubySirius::FormulaResultsApi.new
project_id = 'project_id_example' # String | project-space to read from.
compound_id = 'compound_id_example' # String | compound/feature the formula result belongs to.
opts = { 
  fingerprint: false, # BOOLEAN | add molecular fingerprint to StructureCandidates
  db_links: false, # BOOLEAN | add dbLinks to StructureCandidates
  pub_med_ids: false # BOOLEAN | add PubMedIds (citation count) to StructureCandidates
}

begin
  #Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).
  result = api_instance.get_top_structure_candidate(project_id, compound_id, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling FormulaResultsApi->get_top_structure_candidate: #{e}"
end

api_instance = RubySirius::GraphicalUserInterfaceApi.new
body = RubySirius::GuiParameters.new # GuiParameters | parameters that should be applied.
project_id = 'project_id_example' # String | of project-space the GUI instance is connected to.


begin
  #Apply given changes to the running GUI instance.
  api_instance.apply_to_gui(body, project_id)
rescue RubySirius::ApiError => e
  puts "Exception when calling GraphicalUserInterfaceApi->apply_to_gui: #{e}"
end

api_instance = RubySirius::GraphicalUserInterfaceApi.new
project_id = 'project_id_example' # String | if project-space the GUI instance is connected to.


begin
  #Close GUI instance of given project-space if available.
  api_instance.close_gui(project_id)
rescue RubySirius::ApiError => e
  puts "Exception when calling GraphicalUserInterfaceApi->close_gui: #{e}"
end

api_instance = RubySirius::GraphicalUserInterfaceApi.new
project_id = 'project_id_example' # String | of project-space the GUI instance will connect to.
opts = { 
  read_only: true # BOOLEAN | open in read-only mode.
}

begin
  #Open GUI instance on specified project-space and bring the GUI window to foreground.
  api_instance.open_gui(project_id, opts)
rescue RubySirius::ApiError => e
  puts "Exception when calling GraphicalUserInterfaceApi->open_gui: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new
opts = { 
  include_subs: false # BOOLEAN | include available and active subscriptions in {@link AccountInfo AccountInfo}.
}

begin
  #Get information about the account currently logged in.
  result = api_instance.get_account_info(opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->get_account_info: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new

begin
  #Get SignUp URL (For signUp via web browser)
  result = api_instance.get_sign_up_url
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->get_sign_up_url: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new

begin
  #Get available subscriptions of the account currently logged in.
  result = api_instance.get_subscriptions
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->get_subscriptions: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new

begin
  #Check if a user is logged in.
  result = api_instance.is_logged_in
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->is_logged_in: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new
body = RubySirius::AccountCredentials.new # AccountCredentials | used to log in.
accept_terms = true # BOOLEAN | 
opts = { 
  fail_when_logged_in: false, # BOOLEAN | if true request fails if an active login already exists.
  include_subs: false # BOOLEAN | include available and active subscriptions in {@link AccountInfo AccountInfo}.
}

begin
  #Login into SIRIUS web services.
  result = api_instance.login(body, accept_terms, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->login: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new

begin
  #Logout from SIRIUS web services.
  api_instance.logout
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->logout: #{e}"
end

api_instance = RubySirius::LoginAndAccountApi.new

begin
  #Open SignUp window in system browser and return signUp link.
  result = api_instance.sign_up
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling LoginAndAccountApi->sign_up: #{e}"
end

api_instance = RubySirius::ProjectSpacesApi.new
project_id = 'project_id_example' # String | unique name/identifier of the  project-space to be closed.


begin
  #Close project-space and remove it from application.
  api_instance.close_project_space(project_id)
rescue RubySirius::ApiError => e
  puts "Exception when calling ProjectSpacesApi->close_project_space: #{e}"
end

api_instance = RubySirius::ProjectSpacesApi.new
project_id = 'project_id_example' # String | unique name/identifier that shall be used to access the newly created project-space.
path_to_project = 'path_to_project_example' # String | 
opts = { 
  path_to_source_project: 'path_to_source_project_example', # String | 
  await_import: true # BOOLEAN | 
}

begin
  #Create and open a new project-space at given location and make it accessible via the given projectId.
  result = api_instance.create_project_space(project_id, path_to_project, opts)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ProjectSpacesApi->create_project_space: #{e}"
end

api_instance = RubySirius::ProjectSpacesApi.new
project_id = 'project_id_example' # String | unique name/identifier tof the project-space to be accessed.


begin
  #Get project space info by its projectId.
  result = api_instance.get_project_space(project_id)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ProjectSpacesApi->get_project_space: #{e}"
end

api_instance = RubySirius::ProjectSpacesApi.new

begin
  #List all opened project spaces.
  result = api_instance.get_project_spaces
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ProjectSpacesApi->get_project_spaces: #{e}"
end

api_instance = RubySirius::ProjectSpacesApi.new
project_id = 'project_id_example' # String | unique name/identifier that shall be used to access the opened project-space.
path_to_project = 'path_to_project_example' # String | 


begin
  #Open an existing project-space and make it accessible via the given projectId.
  result = api_instance.open_project_space(project_id, path_to_project)
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling ProjectSpacesApi->open_project_space: #{e}"
end

api_instance = RubySirius::VersionInfoControllerApi.new

begin
  result = api_instance.get_version_info
  p result
rescue RubySirius::ApiError => e
  puts "Exception when calling VersionInfoControllerApi->get_version_info: #{e}"
end
```

## Documentation for API Endpoints

All URIs are relative to *http://localhost:8080*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*RubySirius::CompoundsApi* | [**delete_compound**](docs/CompoundsApi.md#delete_compound) | **DELETE** /api/projects/{projectId}/compounds/{cid} | Delete compound/feature with the given identifier from the specified project-space.
*RubySirius::CompoundsApi* | [**get_compound**](docs/CompoundsApi.md#get_compound) | **GET** /api/projects/{projectId}/compounds/{cid} | Get compound/feature with the given identifier from the specified project-space.
*RubySirius::CompoundsApi* | [**get_compounds**](docs/CompoundsApi.md#get_compounds) | **GET** /api/projects/{projectId}/compounds | Get all available compounds/features in the given project-space.
*RubySirius::CompoundsApi* | [**import_compounds**](docs/CompoundsApi.md#import_compounds) | **POST** /api/projects/{projectId}/compounds | Import ms/ms data in given format from local filesystem into the specified project-space
*RubySirius::CompoundsApi* | [**import_compounds_from_string**](docs/CompoundsApi.md#import_compounds_from_string) | **POST** /api/projects/{projectId}/compounds/import-from-string | Import ms/ms data from the given format into the specified project-space  Possible formats (ms, mgf, cef, msp, mzML, mzXML)
*RubySirius::ComputationsApi* | [**delete_job**](docs/ComputationsApi.md#delete_job) | **DELETE** /api/projects/{projectId}/jobs/{jobId} | Delete job.
*RubySirius::ComputationsApi* | [**delete_job_config**](docs/ComputationsApi.md#delete_job_config) | **DELETE** /api/job-configs/{name} | Delete job configuration with given name.
*RubySirius::ComputationsApi* | [**get_default_job_config**](docs/ComputationsApi.md#get_default_job_config) | **GET** /api/default-job-config | Request default job configuration
*RubySirius::ComputationsApi* | [**get_job**](docs/ComputationsApi.md#get_job) | **GET** /api/projects/{projectId}/jobs/{jobId} | Get job information and its current state and progress (if available).
*RubySirius::ComputationsApi* | [**get_job_config**](docs/ComputationsApi.md#get_job_config) | **GET** /api/job-configs/{name} | Request job configuration with given name.
*RubySirius::ComputationsApi* | [**get_job_configs**](docs/ComputationsApi.md#get_job_configs) | **GET** /api/job-configs | Request all available job configurations
*RubySirius::ComputationsApi* | [**get_jobs**](docs/ComputationsApi.md#get_jobs) | **GET** /api/projects/{projectId}/jobs | Get job information and its current state and progress (if available).
*RubySirius::ComputationsApi* | [**post_job_config**](docs/ComputationsApi.md#post_job_config) | **POST** /api/job-configs/{name} | Add new job configuration with given name.
*RubySirius::ComputationsApi* | [**start_job**](docs/ComputationsApi.md#start_job) | **POST** /api/projects/{projectId}/jobs | Start computation for given compounds and with given parameters.
*RubySirius::ComputationsApi* | [**start_job_from_config**](docs/ComputationsApi.md#start_job_from_config) | **POST** /api/projects/{projectId}/jobs-from-config | Start computation for given compounds and with parameters from a stored job-config.
*RubySirius::FormulaResultsApi* | [**get_best_matching_canopus_predictions**](docs/FormulaResultsApi.md#get_best_matching_canopus_predictions) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/best-canopus-predictions | Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,
*RubySirius::FormulaResultsApi* | [**get_canopus_predictions**](docs/FormulaResultsApi.md#get_canopus_predictions) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/canopus-predictions | All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,
*RubySirius::FormulaResultsApi* | [**get_fingerprint_prediction**](docs/FormulaResultsApi.md#get_fingerprint_prediction) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/fingerprint | Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.
*RubySirius::FormulaResultsApi* | [**get_formula_ids**](docs/FormulaResultsApi.md#get_formula_ids) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas | List of all FormulaResultContainers available for this compound/feature with minimal information.
*RubySirius::FormulaResultsApi* | [**get_formula_result**](docs/FormulaResultsApi.md#get_formula_result) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId} | FormulaResultContainers for the given 'formulaId' with minimal information.
*RubySirius::FormulaResultsApi* | [**get_frag_tree**](docs/FormulaResultsApi.md#get_frag_tree) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/tree | Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).
*RubySirius::FormulaResultsApi* | [**get_simulated_isotope_pattern**](docs/FormulaResultsApi.md#get_simulated_isotope_pattern) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/isotope-pattern | Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.
*RubySirius::FormulaResultsApi* | [**get_structure_candidates**](docs/FormulaResultsApi.md#get_structure_candidates) | **GET** /api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/structures | List of StructureCandidates the given 'formulaId' with minimal information.
*RubySirius::FormulaResultsApi* | [**get_top_structure_candidate**](docs/FormulaResultsApi.md#get_top_structure_candidate) | **GET** /api/projects/{projectId}/compounds/{compoundId}/top-structure | Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).
*RubySirius::GraphicalUserInterfaceApi* | [**apply_to_gui**](docs/GraphicalUserInterfaceApi.md#apply_to_gui) | **PATCH** /api/projects/{projectId}/gui | Apply given changes to the running GUI instance.
*RubySirius::GraphicalUserInterfaceApi* | [**close_gui**](docs/GraphicalUserInterfaceApi.md#close_gui) | **DELETE** /api/projects/{projectId}/gui | Close GUI instance of given project-space if available.
*RubySirius::GraphicalUserInterfaceApi* | [**open_gui**](docs/GraphicalUserInterfaceApi.md#open_gui) | **POST** /api/projects/{projectId}/gui | Open GUI instance on specified project-space and bring the GUI window to foreground.
*RubySirius::LoginAndAccountApi* | [**get_account_info**](docs/LoginAndAccountApi.md#get_account_info) | **GET** /api/account/ | Get information about the account currently logged in.
*RubySirius::LoginAndAccountApi* | [**get_sign_up_url**](docs/LoginAndAccountApi.md#get_sign_up_url) | **GET** /api/account/signUpURL | Get SignUp URL (For signUp via web browser)
*RubySirius::LoginAndAccountApi* | [**get_subscriptions**](docs/LoginAndAccountApi.md#get_subscriptions) | **GET** /api/account/subscriptions | Get available subscriptions of the account currently logged in.
*RubySirius::LoginAndAccountApi* | [**is_logged_in**](docs/LoginAndAccountApi.md#is_logged_in) | **GET** /api/account/isLoggedIn | Check if a user is logged in.
*RubySirius::LoginAndAccountApi* | [**login**](docs/LoginAndAccountApi.md#login) | **POST** /api/account/login | Login into SIRIUS web services.
*RubySirius::LoginAndAccountApi* | [**logout**](docs/LoginAndAccountApi.md#logout) | **POST** /api/account/logout | Logout from SIRIUS web services.
*RubySirius::LoginAndAccountApi* | [**sign_up**](docs/LoginAndAccountApi.md#sign_up) | **GET** /api/account/signUp | Open SignUp window in system browser and return signUp link.
*RubySirius::ProjectSpacesApi* | [**close_project_space**](docs/ProjectSpacesApi.md#close_project_space) | **DELETE** /api/projects/{projectId} | Close project-space and remove it from application.
*RubySirius::ProjectSpacesApi* | [**create_project_space**](docs/ProjectSpacesApi.md#create_project_space) | **POST** /api/projects/{projectId} | Create and open a new project-space at given location and make it accessible via the given projectId.
*RubySirius::ProjectSpacesApi* | [**get_project_space**](docs/ProjectSpacesApi.md#get_project_space) | **GET** /api/projects/{projectId} | Get project space info by its projectId.
*RubySirius::ProjectSpacesApi* | [**get_project_spaces**](docs/ProjectSpacesApi.md#get_project_spaces) | **GET** /api/projects | List all opened project spaces.
*RubySirius::ProjectSpacesApi* | [**open_project_space**](docs/ProjectSpacesApi.md#open_project_space) | **PUT** /api/projects/{projectId} | Open an existing project-space and make it accessible via the given projectId.
*RubySirius::VersionInfoControllerApi* | [**get_version_info**](docs/VersionInfoControllerApi.md#get_version_info) | **GET** /api/version.json | 

## Documentation for Models

 - [RubySirius::AccountCredentials](docs/AccountCredentials.md)
 - [RubySirius::AccountInfo](docs/AccountInfo.md)
 - [RubySirius::AnnotatedPeak](docs/AnnotatedPeak.md)
 - [RubySirius::AnnotatedSpectrum](docs/AnnotatedSpectrum.md)
 - [RubySirius::Canopus](docs/Canopus.md)
 - [RubySirius::CanopusPredictions](docs/CanopusPredictions.md)
 - [RubySirius::CollisionEnergy](docs/CollisionEnergy.md)
 - [RubySirius::CompoundAnnotation](docs/CompoundAnnotation.md)
 - [RubySirius::CompoundClass](docs/CompoundClass.md)
 - [RubySirius::CompoundClasses](docs/CompoundClasses.md)
 - [RubySirius::CompoundId](docs/CompoundId.md)
 - [RubySirius::DBLink](docs/DBLink.md)
 - [RubySirius::Deviation](docs/Deviation.md)
 - [RubySirius::FingerprintPrediction](docs/FingerprintPrediction.md)
 - [RubySirius::FormulaCandidate](docs/FormulaCandidate.md)
 - [RubySirius::FormulaResultContainer](docs/FormulaResultContainer.md)
 - [RubySirius::FragmentNode](docs/FragmentNode.md)
 - [RubySirius::FragmentationTree](docs/FragmentationTree.md)
 - [RubySirius::GuiParameters](docs/GuiParameters.md)
 - [RubySirius::JobId](docs/JobId.md)
 - [RubySirius::JobProgress](docs/JobProgress.md)
 - [RubySirius::JobSubmission](docs/JobSubmission.md)
 - [RubySirius::LossEdge](docs/LossEdge.md)
 - [RubySirius::MsData](docs/MsData.md)
 - [RubySirius::PeakAnnotation](docs/PeakAnnotation.md)
 - [RubySirius::ProjectSpaceId](docs/ProjectSpaceId.md)
 - [RubySirius::ResultOverview](docs/ResultOverview.md)
 - [RubySirius::Sirius](docs/Sirius.md)
 - [RubySirius::StructureCandidate](docs/StructureCandidate.md)
 - [RubySirius::StructureDbSearch](docs/StructureDbSearch.md)
 - [RubySirius::Subscription](docs/Subscription.md)
 - [RubySirius::Timeout](docs/Timeout.md)
 - [RubySirius::UseHeuristic](docs/UseHeuristic.md)
 - [RubySirius::Zodiac](docs/Zodiac.md)
 - [RubySirius::ZodiacEdgeFilterThresholds](docs/ZodiacEdgeFilterThresholds.md)
 - [RubySirius::ZodiacEpochs](docs/ZodiacEpochs.md)
 - [RubySirius::ZodiacNumberOfConsideredCandidatesAt300Mz](docs/ZodiacNumberOfConsideredCandidatesAt300Mz.md)
 - [RubySirius::ZodiacNumberOfConsideredCandidatesAt800Mz](docs/ZodiacNumberOfConsideredCandidatesAt800Mz.md)
 - [RubySirius::ZodiacRunInTwoSteps](docs/ZodiacRunInTwoSteps.md)

## Documentation for Authorization

 All endpoints do not require authorization.

